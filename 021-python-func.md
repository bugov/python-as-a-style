# Первый рефакторинг

Важной частью работы программиста является декомпозиция задач. То есть
навык разбиения сложных контрактов на маленькие. При этом каждый
маленький должен быть простым и независимым – чтобы в конкретный момент
времени нам нужно было думать о небольшом колиестве проблем и помнить минимум
договорённостей. Естественно, в сумме эти маленькие контаркты должны соответствовать
большому.

Один из базовых подходов к разбиению кода на части – это процедуры, либо же функции.
Функции представлены в языке Python, мы уже успели с ними познакомиться:
те же help и print. В общем виде их можно описать слежующим образом:

```Py
def имя_функции_в_snake_case(параметр1, параметр2=значение_по_умолчанию):
    """
    Описание функции
    Описание параметров функции
    Описание ожидаемых исключений и возвращаемых значений
    """
    код
```

Давайте попытаемся упростить нашу программу с помощью функций. Для этого
возьмём бумажку и ручку / карандаш и запишем, что делает программа:

1. Читает ввод информации от пользователя.
2. Проверяет ввод на правильность (поддерживаем ли мы команду).
3. Подготавливает входные параметры для работы.
4. Команды:
  - выйти,
  - показать список,
  - добавить в список,
  - удалить из списка.
5. Выводит сообщения об ошибках.

-- на самом деле, почти каждая программа занимается этим. В зависимости от
сложности программы эти части могут быть как просто строками кода,
так и функциями и даже отдельными серверами. Мы пока что остановимся
на функциях.

Что вообще стоит объявлять отдельной функцией, а что неплохо живёт как
строки кода в рамках другой функции? Пожалуй самый частый ответ, который
можно услышать на этот вопрос: то, что используется несколько раз --
таким образом мы не дублируем код.

Однако, дублирование кода -- это лишь симптом того, что в разных местах нам нужны
одни и те же действия. И мы их делаем над подобными данными... Звучит как контракт!
Как раз от ясного и простого контракта и стоит отталкиваться при определении,
что сделать функцией. Всё же нам нужно именно поделить большой контракт на маленькие,
чтобы было проще реализовать.

Итак, к коду:

```Py
from typing import List


def get_user_command() -> List[str]:
    command = input('>')
    return command.split(' ', maxsplit=1)
```

-- выделим получение ввода в отдельную функцию. Также добавим первичную обработку
пользовательских данных, чтобы в более удобном виде получать команды.

Из нового здесь мы можем увидеть возможность описания типа возвращаемого
значения: `-> List[str]`. Эта информация полезна для программиста и
средств разработки -- помогает чётче указать контракт функции. Также
это будет отображаться в help(get_user_command):

```
>>> help(get_user_command)

get_user_command() -> List[str]
```

Таким образом мы написали функцию, описание которой само документиует эту функцию.
Далее предлагаю заняться пользовательскими командами:

```Py
from typing import List


def quit(todo_list: List[str]):
    exit(0)


def print_todo(todo_list: List[str]):
    number = 1

    for item in todo_list:
        print(str(number) + ". " + item)
        number += 1


def add_to_todo(todo_list: List[str], note: str):
    todo_list.append(note)


def remove_from_todo(todo_list: List[str], number: str):
    index = int(number) - 1
    del(todo_list[index])
```

Здесь интересно, что некоторые функции состоят из одной строки. Однако,
выделив команды в одельные действия, мы создаём новый уровень абстракции.
Так что для единообразия все они становятся сущностями одного порядка --
функциями.

Другой забавный момент состаит в том, что мы пытались выделить команды
в функции, создав для них простой и логичный интерфейс (контракт).
Однако, если обратить внимание на функцию `remove_from_todo`, можно
заметить, что помимо непосредственно удаления элемента по индексу,
мы ещё занимались изменением представления данных. Строковое представление
номера дела из списка-делл мы преобразовали к числовому, более того --
индексному (сдвигу от начала).

Стоило ли преобразование выделить в отдельный уровень абстракции, в отдельную функцию?
Возможно. Во всём важно чуство меры. И даже в том, как мы выделили
команды в функции многие углядят излишество. При росте программы, вероятно,
нам действительно понадобится выделить подобные преобразование (очистку)
пользовательских жанных в отдельный слой. Так что знаем об этом, держим
в голове такую возможность, и продолжаем работать с тем, над чем начали --
с командами!

И вот уж где-где, так на

```Py
def quit(todo_list: List[str]):
    exit(0)
```

-- точно должен появиться вопрос. Зачем передавать что-то, если мы это
не используем? Всё просто: это команды для работы со списком дел.
Равно как и в остальных командах, мы передаём список дел -- одинаковые
действия делаем одинаково. Так может стоит "quit" исключить из "команд"?
Ещё один тип абстракции мне кажется дороже, чем маленькая неочевидноять
в одном из экземпляров данной абстракции. Также есть подозрение,
что на следующем этапе на `quit` мы добавим сохранение списка.
Не факт, но кажется логичным.

Также стоит обратить внимание на то, что здесь мы использовали type hinting
для описания типов параметров функции. Ровно те же предпосылки -- чётче
и яснее прописать контракт. В отличии от описния типа возвращаемого функцией
значения, в параметрах параметр от типа отделяется двоеточием.

Теперь давайте всё это объединим в один общий контракт:

```Py
COMMANDS = {
    'quit': quit,
    'list': print_todo,
    'add': add_to_todo,
    'remove': remove_from_todo,
}


def main():
    todo = list()

    while True:
        command, *args = get_user_command()

        if command not in COMMANDS:
            print("[!] Invalid command")
            continue

        COMMANDS[command](todo, *args)
        print("[+] Done")


main()
```

В итоге код стал немного больше, однако, каждая его часть проще. Команды
мы сгруппировали в `dict` "`COMMANDS`", так то ещё раз подчеркнули,
что это сущности одного порядка. Более того благодаря этому мы довольно
просто спроецировали пользовательские команды на наши функции.

## Немного о звёздах

Также из нового мы могли увидеть

```Py
command, *args = get_user_command()
```

-- как и до этого, мы получаем результат выполнения в виде списка и
раскидываем результат по переменным. Но если мы укажем переменную с `*`,
то в этом случае она будет списком и "съест" все оставшиеся переданные данные.
Например,

```Py
>>> first, second, *other = range(1, 10)
>>> first
1
>>> second
2
>>> other
[3, 4, 5, 6, 7, 8, 9]
```

И даже так:

```Py
>>> first, second, *other, one_more = range(1, 10)
>>> other
[3, 4, 5, 6, 7, 8]
>>> one_more
9
```

Однако, далее мы применяем звёздочку к массиву `args` для того чтобы
представить массив как набор аргументов вызова функции. Например,

```Py
>>> def sum(a: int, b: int) -> int:
...     return a + b
...
>>> nums = [1, 2]
>>> sum(*nums)
3
```

Аналогичный механизм существует внутри функции. Мы можем собрать все
позиционные переменные в один массив, сколько бы их ни было:

```Py
>>> def filter_odd(*nums):
...     odd_nums = []
...     for num in nums:
...         if num % 2:
...             odd_nums.append(num)
...     return odd_nums
...
>>> filter_odd(1, 2, 3, 4)
[1, 3]
>>> filter_odd(1, 2, 3, 4, 5, 6, 7)
[1, 3, 5, 7]
```

-- складываем все позиционные параметры функции в список `nums` и работаем
с параметрами уже как со списком.

Однако, я всё говорю "позиционные" -- значит, есть и непозиционные.
Вместо порядкого номера переменной можно использовать название переменной.
Так вышеописанная функция `sum` может быть вызвана следующим образом:

```Py
>>> sum(b=2, a=1)
3
```
