# Первая программа

Чтобы не ходить вокруг да около, начнём с довольно наивного, но вполне
рабочего кода на Python. Не беспокойтесь, если что-то будет непонятным.
Сконцентрируйтесь на том, что вы можете понять из этого:

```Py
# todo.py

todo = list()

while True:
    command = input('> ')

    if command == 'quit':
        break

    if command == 'list':
        number = 1

        for item in todo:
            print(str(number) + ". " + item)
            number += 1

        continue

    if ' ' not in command:
        print("[!] Invalid command")
        continue

    command, argument = command.split(' ', 1)

    if command == 'add':
        todo.append(argument)
        print("[+] Done")
    elif command == 'remove':
        index = int(argument) - 1
        del(todo[index])
        print("[+] Done")
    else:
        print("[!] Invalid command")
```

Теперь, когда в общих мы поняли, что происходит,
сохраним этот кода в файл `todo.py` и запутим его:

```
$ python3 todo.py
> add Попить чай
[+] Done
> add Съесть булочку
[+] Done
> add Вымыть чашку
[+] Done
> list
1. Попить чай
2. Съесть булочку
3. Вымыть чашку
> remove 2
[+] Done
> list
1. Попить чай
2. Вымыть чашку
> remove 1
[+] Done
> list    
1. Вымыть чашку
> quit
```

Итак, это программа для ведения списка дел. Когда мы поняли, что это, было
бы неплохо разобраться, как это работает!

Первая строка – это комментарий.  **Комментарии** начинаются с символа `#` и
продолжаются до конца строки. Комментарии используются для описания сложных
и непонятных учатков кода. В идеале они отсутствуют – код программы – сам по
себе должен понятно описывать происходящее.

Так, например, ниже мы присваиваем переменной пустой список:

```Py
todo = list()
```

– но мы не пишем комментарий об этом, ведь это очевидно!

Но что такое **переменная**? По сути, переменная – это название,
которое мы даём чему-то, чтобы впоследствии
иметь возможность к этому обратиться и воспользоваться (как бы негуманно это ни звучало).

В данном случае – мы даём имя пустому списку. А из названия, которое мы ему дали,
можно понять, что это список дел.

Список же мы получаем из функции-конструктора `list`. Если ей передать на вход
что-то, из чего она может сделать список - она его сделает. Мы вернёмся к этому позднее.
На данный момент – мы ничего не передали, потому и список пустой. Логично?

В 5-ой строке можно увидеть `while True:` – "пока Истина", иначе говоря –
"всегда". Таким образом мы делаем вечный цикл – цикл событий, которые мы будем
обрабатывать.

```Py
command = input('> ')
```

– а это как раз наше событие – мы будем раз за разом получать ввод от пользователя.
Так как язык Python использует динамическую типизацию, мы не указываем тип и
не объявляем заранее переменну. Вместо этого мы присваиваем значение –
в этот момент и определяется тип переменной. В данном случае `command` – строка.

```Py
if command == 'quit':
    break
```

Сразу обработаем команду выхода из нашего вечного цикла – "quit". Замечу,
что в питоне можно не ставить круглые скобки, обрамляющие условие входа в блок.

Как и во многих других языках, проверка на равенство осуществляется оператором
`==`. А для выхода из цикла используется команда `break`.

Далее – аналогично для команды `list`, но появляется интересный цикл по
списку дел:

```Py
if command == 'list':
    number = 1

    for item in todo:
        print(str(number) + ". " + item)
        number += 1

    continue
```

Для нумерации мы используем переменную `number` – заметьте, названия переменной
и контекста использования хватает для понимания её предназначения.

А для `for` циклов в питоне используется следующий синтаксис:

```Py
for элелемент in список:
    блок действий с элементом
else:
    Необязательный блок для случая, когда произошёл break
```

Логично рассудив, что циклы часто используются для обхода элементов различных
списко-подобных структур, именно такой тип `for` в питоне и стали использовать.

В нашем случае мы печатаем строковое представление номера элемента в списке,
объединяем его с точкой и отступом. Затем – добавляем название нашего дела,
предполагая, что дела мы храним в строках, либо же они могут быть автоматом
преобразованы в строки.

В Python нет оператора `++` для увеличения на 1 числа, поэтому мы воспользуемся
краткой записью `number += 1`, что эквивалентно `number = number + 1`.

Это всё, что требуется от команды `list` нашего приложения – обрываем ход
выполнения нашего цикла, переходя к следующей команде. Для перехода
к следующей итерации цикла используется команда `continue`.

Мы могли бы не обрывать ход выполнения цикла, а просто все остальные инструкции
положить в ветку `else` для нашего условия `if command == 'list'`.
Синтаксически и логически это было бы верно, но мы бы сдвинули весь последующий
код на один уровень вправо, сделав визуально "горку". Такой код сложнее читать.
Старайтесь иметь не слишком "глубокий" код, чтобы в нём не "утонуть".

Далее мы начинаем работу с составными командами, где аргумент отделён пробелом
– самое время проверить, есть ли в команде пробел:

```Py
if ' ' not in command:
    print("[!] Invalid command")
    continue
```

Всё это мы уже видели кроме `not in` – это довольно эстетически красивый
синтаксис проверки наличия элемента в списке/коллекции. Строки в Python
во многом похожи на этакие массивы символов (строк из одной буквы). Однако,
это отдельный тип данных. Более того – иммутабельный, то есть его нельзя
изменять. Например, получить символ по индексу вы можете, а изменить нет:

```Py
>>> test_string = "Hello!"
>>> test_string[3]   
'l'
>>> test_string[0]
'H'
>>> test_string[0] = 'h'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```

– легко проверить в нашем "python-калькуляторе".

Далее мы делим нашу команду по пробелу 1 раз, используя встроенный метод для строк:

```Py
command, argument = command.split(' ', 1)
```

Слева – переменные, которым будет присвоен результат, слева – вызов
метода строки, где первый параметр – по какому символу делим, второй – сколько раз
(опционалный параметр).

Заметьте, переменные можно переобъявлять, они могут иметь другое значение!
Частое и неоправданное использование данной возможности ведёт к непонятности
и запутанности кода. Возможно, где-то ниже по коду кто-то ожидает увидеть
в переменной `command` именно изначально введённую команду. Но я уповаю на
внимательность программистов, которые будут читать этот код (зря-зря-зря) и
на то, что суть данных, которые я сейчас храню, отлично отражается этим названием.

Теперь можно описать работу наших "сложных" команд:

```Py
if command == 'add':
    todo.append(argument)
    print("[+] Done")
```

– уже изветный нам `if`, а вот `todo.append` – уже что-то новое. На самом деле,
это встроенный в `list` метод – добавления элемента в конец списка. Так
что всё логично. Ну и не забываем сказать пользователю, что всё прошло хорошо –
обратная связь очень важна, иначе мы оставляем пользователя нашей программы один
на один с сомнениями, а это делать опасно!

Здесь мы опять же всё сделали, так что можно было сделать `continue`, но
мне захотелось вам показать полную версию управляющей конструкции `if-elif-else`.
Из такого названия понятно, что в ней возможны 3 вида блоков:

1. один блок `if` – для уловия выполнения первой ветки логики;
2. хоть сколько блоков `elif` – они как `if`, только не главный – проверяются,
   если `if` ложен (проверяются один за другим до первой "истины");
3. ни одного, или таки один блок `else` – если ничто не подошло.

Итак, наша команда удаления из списка дел:

```Py
elif command == 'remove':
    index = int(argument) - 1
    del(todo[index])
    print("[+] Done")
```

– мы берём аргумент (строку), приводим её к целому числу и вычитаем единицу.
Понятно, для чего приводим к числу – вычитать из строки число – странное занятие
(попробуйте в "калькуляторе"). Но зачем мы вычитаем единицу? Всё просто –
нумерация элементов списка начинается с 0, а люди привыкли к началу нумерации с 1.
И, так как мы любим своих пользователей, показываем им информацию (и принимаем от них)
в удобном им виде. Нам не сложно, людям приятно!

Ну и если ничто не подошло – информируем об это пользователя:

```Py
else:
    print("[!] Invalid command")
```

– не молчим, не сыпем ошибки. Всё спокойно и эстетично.

## Стиль, читаемость и PEP-8

Итак, мы написали и разобрали по частям нашу программу, но рано расслабляться.
Откуда мы знаем, что наша программа хороша? Вообще, что значит, что программа хороша?

Один из критериев качества программы является её читаемость. Практика показывает,
что читается программа чаще, чем пишется. Очень мало программ пишутся
в один присест – то данных не хватает, то пользователь что-то ещё захочет.
Поэтому программа изменяется версия за версией. И каждый раз надо не писать
всё с нуля, а дорабатывать. Поэтому важно писать понятный код.

Одной из "фишек" языка питон является PEP-8, в котором почти формально
описаны правила хорошего кода. Можете загуглить и прочитать. А раз есть
првила, можно и написать программу, проверяющую их. Например, `pycodestyle`.

Проверим нашу программу с помощью `pycodestyle`:

```Bash
$ pycodestyle ./todo.py

```

Хм... Мы действительно написали неплохую, исходя из критериев `pycodestyle`
программу! Теперь давайте каждый как-нибудь поиздеваемся над кодом и запустим снова!
Я, например, изменю размер отступов, сделаю плохие названия переменных и ещё чуть-чуть
пошалю!

В итоге, получаю замечания по своему коду с указанием строк/столбцов, и даже
описание на английском!

```Bash
$ pycodestyle ./todo.py
./todo.py:8:25: E701 multiple statements on one line (colon)
./todo.py:14:11: E111 indentation is not a multiple of four
./todo.py:15:11: E111 indentation is not a multiple of four
```

PEP-8 – это не гарант хорошего кода. Всегда можно всё сделать плохо, но формально
хорошо. Однако, он помогает придерживаться многим людям такого стиля, который
им всем понятен.

## Философия Python

Помимо формальных правил есть ещё и общефилософские. Для Python они описаны,
и их можно получить, написав в "калькуляторе":

```
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

Иначе говоря:

```
Красивое лучше, чем уродливое.
Явное лучше, чем неявное.
Простое лучше, чем сложное.
Сложное лучше, чем запутанное.
Плоское лучше, чем вложенное.
Разреженное лучше, чем плотное.
Читаемость имеет значение.
Особые случаи не настолько особые, чтобы нарушать правила.
При этом практичность важнее безупречности.
Ошибки никогда не должны замалчиваться.
Если не замалчиваются явно.
Встретив двусмысленность, отбрось искушение угадать.
Должен существовать один — и, желательно, только один — очевидный способ сделать это.
Хотя он поначалу может быть и не очевиден, если вы не голландец.
Сейчас лучше, чем никогда.
Хотя никогда зачастую лучше, чем прямо сейчас.
Если реализацию сложно объяснить — идея плоха.
Если реализацию легко объяснить — идея, возможно, хороша.
Пространства имён — отличная штука! Будем делать их побольше!
```

Важно понимать, что Python – это не только язык программирования, а ещё и во многом
культура программирования, что часто даже важнее.
