# Первые тесты и первый рефакторинг

Мы уже успели поговорить о том, как важно писать читаемый код. Основной довод
стараться писать читаемый код – код читается гораздо чаще, чем пишется.
Даже смогли как-то формально проверить качество нашего кода.

Однако, когда мы не просто программируем, а пишем программы, которые
живут, используются, дорабатываются, портируются... нам нужно часто вносить
изменения в код. Для того, чтобы быть уверенным, что ничего из старой функциональности
мы не поломали – надо как-то зафиксировать требования к коду, программе.
Определить контракт, по которому она работает.

## Немного о тестировании

В простейшем случае – программа не должна падать при запуске. То есть
даже банальный запуск уже даёт нам информацию – так называемый "smoke test" –
а не задымится ли при "включении в сеть питания".

Также мы можем в стиле ручного тестирования постараться продумать все
возможные сценарии использования нашей программы. Это очень сложный и
муторный процесс. Он становится ещё менее приятным от того, что при каждой
доработке нужно будет всё проверять по-новой. Это называется ручным регрессионным
тестированием (на наличие регрессий) – более подробно об этом увлекательном
занятии вам расскажут тестировщики.

Боль с повторяющимися монотонными действиями мы можем автоматизировать
простыми скриптами: от написания небольшого input/output скрипта на Bash,
до тестирования веб-интерфейса с помощью специализированного фреймворка.
Однако, никуда не исчезает при этом проблема с большим количеством тестов,
с высокой вариативностью использования программы.

И тут нам бы по-хорошему, как-то поделить код на части, сделать из одного
большого контракта кучу маленьких.

## Вариант реорганизации кода с использованием функций

Важной частью работы программиста является декомпозиция задач. То есть
навык разбиения сложных контрактов на маленькие. При этом каждый
маленький должен быть простым и независимым – чтобы в конкретный момент
времени нам нужно было думать о небольшом колиестве проблем и помнить минимум
договорённостей. Естественно, в сумме эти маленькие контаркты должны соответствовать
большому.

Один из базовых подходов к разбиению кода на части – это процедуры, либо же функции.
Функции представлены в языке Python, мы уже успели с ними познакомиться:
те же help и print. В общем виде их можно описать слежующим образом:

```Py
def имя_функции_в_snake_case(параметр1, параметр2=значение_по_умолчанию):
    """
    Описание функции
    Описание параметров функции
    Описание ожидаемых исключений и возвращаемых значений
    """
    код
```

Название функции мы пишем также как и остальные "обычные" переменные –
в snake_case. Однако, если переменные зачастую существительные, то функции –
это некоторые действия над ними – глаголы. По крайней мере, первое слово –
глагол.

Также некоторые функции проверяют что-либо и возвращают белево значение
(True или False) – в этом случае хорошо читается, когда они начинаются с "is"
или "check".

Пример:

```Py
class PositiveDoesNotExist(ValueError):
    """Use in case of missing positive elements in sequence"""


def get_first_positive(sequence):
    """
    Returns first positive element in sequence.

    Args:
        sequence (Iterable): an iterable collection comparable to 0 items.

    Returns:
        Any: an item of the collection which positive and closest to start.

    Raises:
        TypeError: in case of non-iterable collection.
        TypeError: in case of non-comparable to 0 item.
        DoesNotExist: in case of missing positive elements in sequence.

    Examples:
        >>> get_first_positive([-1, 0, 2, 6])
        2
    """
    for item in sequence:
        if item > 0:
            return item

    raise PositiveDoesNotExist(f'Cannot find a positive element in: {sequence!r}')


if __name__ == '__main__':
    assert get_first_positive([-1, 0, 2, 6]) == 2

    try:
        get_first_positive(None)
    except TypeError:
        pass

    try:
        get_first_positive([None])
    except TypeError:
        pass

    try:
        get_first_positive([-1, -2, -3])
    except PositiveDoesNotExist:
        pass
```

С некоторыми конструкциями мы ещё не встречались, но как и в предыдущей теме,
думаю, общий замысел ясен. Тем не менее, мы всё равно разберём всё "по косточкам".

### Лирическое отступление про исключения и исключительные ситуации

```Py
class PositiveDoesNotExist(ValueError):
    """Raise in case of missing positive elements in sequence"""
```

Для начала мы определили класс исключение, который наследуется от класса
ValueError (определённый стандартом Python класс исключений). Ничего
дополнительного тому, что есть в ValueError в нём нет. Однако, мы определяем
свой класс для того, чтобы разделять свои исключительные ситуации и чужие.
Также мы написали свой doc-string, чтобы документировать для других программистов
или себя в будущем, какие задачи выполняет этот класс.

Про исключения мы поговорим в другой теме, равно как и про классы и объекты.
Знания по программированию состоят из множества фактов и правил – часто
они пересекаются и накладываются друг на друга... С этим тоже надо уметь жить,
воспринимать одни и те же вещи на разных уровнях понимания и абстракции.

Однако, нельзя не сказать про исключения несколько слов – иначе часть кода
останется непонятной даже на базовом уровне.

Чем не являются исключения:

- Это **НЕ** ошибки!
- Это **НЕ** коды возврата!

Исключения, как это не странно – механизм удобной обработки исключительных
ситуаций. В коде, приведённом выше, не понятно, что же мы должны возвращать
в случае, если в последовательности не оказалось положительного элемента.

Некоторые программисты для обработки подобных ситуаций используют значение `None`.
Однако, это именно значение! То есть в общем случае – это вполне нормальное значение,
как `1` или `"some string"`. А в данном случае оно ещё и является абсурдным –
попытка сравнения `None` с `0` приведёт к исключительной ситуации `TypeError`.

Саме же `None` имеет значение "не определено". Например, в поле ответа на вопрос
"Пользуетесь ли вы программой X" могут быть 2 варианта: "Да" (`True`) и "Нет" (`False`).
Но если человек решил пропустить этот вопрос – тогда это именно "не определено" (`None`).

Наследуется наш класс исключения от `ValueError`. Сам `ValueError` используется
для сигнализации о исключительной ситуации, когда нарушается "контракт" на
диапазон допустимых значений для действия / операции. Или же не удаётся
по данному значению совершить операцию. Например, попытаемся найти в
строке "hello" номер символа, с которого начинается подстрока "yellow":

```Py
>>> "hello".index("yellow")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: substring not found
```

Именно благодаря тому, что мы наследовались от класса `ValueError` (точнее,
`BaseException`, но нас сейчас это не интересует), мы можем
его поднять исключение по стеку вызова: `raise PositiveDoesNotExist`.

В момент, когда мы решаем просигнализировать о возникновении исключительной
ситуации, Python по стеку вызовов поднимает наше исключение, пока не найдётся
подходящая конструкция, которая его обработает:

```Py
try:
    get_first_positive([-1, -2, -3])
except PositiveDoesNotExist:
    pass
```

– в блоке `try` код, в котором мы планируем обрабатывать исключительные ситуации,
в `except` мы ожидаем какой-то тип исключений, который хотим обработать.
В нашем случае – возникновение конкретной исключительной ситуации – как раз
требуемое поведение – обработку пропускаем.

В случае, когда синтаксис велит что-то указать, но указывать нечего – можно пропустить
командой `pass`.

Заметьте, если вдруг произойдёт другая исключительная ситуация – мы её
обрабатывать не будем – она поднимется до обработчика самого Python и
наша программа завершится с ненулевым кодом возврата и выводом отладочной информации.
Так что здесь нет никакого сокрытия ошибки, всё честно и информативно... для
программиста.

Подробнее особенности проектирования системы исключений мы разберём позднее,
объяснение выше не претендует на полноту, более того нарочито грешит недоговорками.

### О способах передачи аргументов в функцию
